---
sidebar_position: 1
title: AppWheel SDK Integration Document
id: AppWheel-SDK-Integration-Document
---
# AppWheel SDK Integration Document
## Overall Process
（欠缺流程图，因为现在没有仓库放）
## iOS Integration
### Step 1: Create an app

- **App name:** The name of your app
- **Store:** The platform that is divided into Android and iOS, and you should select iOS in this case.
- **App Bundle ID:** bundleID is the identifier of your app in the Apple App Store, which can be obtained by viewing your app in App Store Connect.
- **iTunesConnect App Specific Shared Secret:** The shared secret, which is needed to verify the order receipt generated by your app. For the acquisition method, please refer to: [https://help.apple.com/app-store-connect/#/devf341c0f01](https://help.apple.com/app-store-connect/#/devf341c0f01). There are two shared keys: One is the shared key for all apps; the other is a shared key for a single app. A shared key for a single app is recommended.

### Step 2: Configuration
#### Notification Receiving Configuration(<font color="red"> **Important: If you have your own receiving server, please refer to the "Configure Notification Receiving Server"**</font>)
To send Apple server notifications to Appwheel, please configure the following address ([https://msgserver-dot-subscription-saas.uc.r.appspot.com/subcenter/receive_ios_notification](https://msgserver-dot-subscription-saas.uc.r.appspot.com/subcenter/receive_ios_notification)) to Apple Store Connect: (Currently supports V1 type notifications)



#### Configure Notification Receiving Server
▪ If you have your own notification receiving server that needs the push data, you can set the receiving server address in the AppWheel main site. We will send each message once in the order in which the messages arrive, but sometimes the messages may not be delivered in sequence, or will be transmitted multiple times. You should design the program in the way of idempotent processing.

￮ After the configuration is complete, you can test the availability of the address. The configuration must be consistent with the requirements, that is, accept the request of the POST method, return 200 Http status code after successful processing, and return 400 or 500 status code when processing fails. In addition, because there is no actual business data body in the test, the 200 http status code can be returned when empty data is received.

#### p8 file configuration for purchasing discounted products
When your app has a discount set in the Apple App Store, and you want to sync the information to AppWheel, you need to set the p8 file in AppWheel。
<todo：缺了一张图，因为没有仓库放>
**Service Account credentials JSON:** A file with a .p8 suffix, commonly called a p8 file. When you need to enable the subscription discount function, you need to have a signature for the discount, and the p8 file is an essential key to generate this signature. Obtain it through: [https://help.apple.com/app-store-connect/#/dev689c93225](https://help.apple.com/app-store-connect/#/dev689c93225])

#### Product Configuration
▪ There's already a product configuration
▪ No product configuration

### Step 3: SDK interface integration
#### 1. Installation
The integration should be done with CocoaPods and the following orders should be added to Podfile.

```Objective-C
pod 'AppWheel'
```

The latest version can be obtained through the official website or by executing pod search AppWheel.
All methods support Swift calls. Please add the following sentences to the Bridging-Header file.

```Objective-C
import <PurchaseSDK/AWPurchaseKit.h>
```


<font color="red">Note: This SDK only supports the real machine rather than a simulator.</font>

#### 2. Initialize
Requirements:
The SDK initialization method is as follows. Please initialize the SDK in your app as soon as possible according to your own situation.

```Objective-C
AWPurchaseKit configureWithAppId:appid uid:userId completion:^(BOOL success, AWError * _Nonnull error) {
    if (success) {
      //init success ,do something
    } else {
      // init failed,check error
    }
  }
```

```Swift
AWPurchaseKit.configure(withAppId: appId, uid: uid) { [weak self](success, error) in
      if success == false {
        // init failed,check error
      } else {
        //init success ,do something
      }
    }
```

##### Parameters:
- appId: Generated by the server of the subscription center. For the generation steps, please refer to the document: New Application (External Use) 
- uid: userId, no empty string for transferring
- completion: Initialization result's block. Returns 'true' if initialization is successful; returns 'false' if not. This component can not be used in the case of configuration failure. 

#### 3. Get Products
Requirements:
This method is used to acquire product information. The product information should be loaded before displaying product page.

```Objective-C
[AWPurchaseKit getProductsInfoWithProductIdentifiers:self.skuSet completion:^(RetrievedProducts * _Nonnull retrievedProducts) {
      if (retrievedProducts.error) {
       // request error,check error msg
        return;
      }
      if (retrievedProducts.validProducts.count){
        dispatch_async(dispatch_get_main_queue(), ^{
        // request success, updateUI
        //  [self updateUI];
        });
      }
      if (retrievedProducts.invalidProductIdentifiers.count) {
        //find invalid sku, check your sku
      }
    }];
```

```Swift
AWPurchaseKit.getProductsInfo(withProductIdentifiers: productIds) { [weak self] (result) in
          if let error = result.error {
            //request error,check error msg
          } else {
            let valid_products = result.validProducts
            //request success, updateUI
          }
  }
```

##### Parameters:
Collection of SKU IDs.
##### Return:
The RetrievedProducts returned includes AWProduct array of successfully obtained products, SKU array of products failed to be obtained and AWError objects.
AWProduct Data Structure: AppWheel SDK Integration Document - Introduction to iOS Classes 

#### 4. Purchase Products
Requirements:
This method should be called to complete a purchase when a user has selected a product. The developers should tell the product type before calling this method and then pass the productType to complete the purchase.

```Objective-C
[AWPurchaseKit purchaseProduct:product quantity:quantity productType:productType paymentDiscount:paymentDiscount completion:^(BOOL success, AWError * _Nonnull error) {
                if (!success) {
                  //purchase failed, check error
                }else {
                  //purchase success
                }
          }];
```

```Swift
AWPurchaseKit.purchaseProduct(product, quantity: 1, productType: AWProductType, paymentDiscount: nil) { success, error in
        if success {
          //purchase success
        } else {
          //purchase failed, check error
        }
      }
```

##### Parameters:
- product: Products
- paymentDiscount: Discounts. Only for subscription products and can be acquired through Product.discounts. No transferable nil. 
- quantity: The quantity of purchases. The quantity of subscription products is 1, as is other product types.
- productType: Type of products. There are usually four types: 0: consumable, 
1: non-consumable, 2: auto-renewable and 3: non-renewable. Users can tell the type according to the SKU. Please refer to the AWProductType in AppWheel SDK Integration Document - Introduction to iOS Classes.

#### 5. Restore Purchase
Requirements:
This is used to restore valid subscriptions, non-consumable products, and non-renewable products for a user. When there is no valid subscription, the 'success' in the block will return a false value. Calling this interface will directly call the AppleService verification interface and there is a quota restriction for this interface for each app. It is strictly prohibited to call when starting the app and to call it too frequently. It is recommended to call it only when the purchase information fails to be inquired because the user changed their phone or reinstalled the app.

```Objective-C
[AWPurchaseKit restorePurchaseWithCompletion:^(BOOL success, NSArray * validSubscriptions, NSArray * purchasedItems, AWError * error) {
    //do something
  }];
```

```Swift
AWPurchaseKit.restorePurchase { (success, validSubscriptions, productIds, error) in
      //do something
      }
 ```

#### 6. View User Benefits
Telling if there is an ongoing subscription service
Requirements:
Tell if a user has an ongoing subscription service. If yes, this method can be used to tell the benefits the user enjoys.

```Objective-C
[[AWPurchaseKit getPurchaseInfo] isSubscriptionUnlockedUser]
```

```Swift
AWPurchaseKit.getPurchaseInfo().isSubscriptionUnlockedUser()
```

Obtain the existing valid subscriptions
Requirements:
It is used to tell a user's existing valid subscription.

```Objective-C
[[AWPurchaseKit getPurchaseInfo] getCurrentValidSubscriptions]
```

```Swift
AWPurchaseKit.getPurchaseInfo().getCurrentValidSubscriptions()
```

Obtain the currently owned non-consumable and non-renewable subscription products.
Requirements:
It is used to obtain the consumable, non-consumable, and non-renewable subscription items currently owned by the user.


```Objective-C
[[AWPurchaseKit getPurchaseInfo] purchasedArray]
```

```Swift
AWPurchaseKit.getPurchaseInfo().purchasedArray()
```

#### 7. Adding a global listener
Requirements:
This method is used to add a global listener, which will be called after purchase, subscription renewal, and/or restoring purchases. Developers should set up listeners as soon as possible after initialization for callbacks in a timely manner.

```Objective-C
///添加监听
[AWPurchaseKit addPurchaseObserver:AWPurchaseObserver];
///移除监听
[AWPurchaseKit removePurchaseObserver:self]
```

```Swift
/// 添加监听
AWPurchaseKit.add(AWPurchaseObserver)
///移除监听
AWPurchaseKit.remove(AWPurchaseObserver)
```

### Step 4: Acceptance Inspection
- □ App Configuration Check
- □ Whether the notification is configured successfully: Check the configuration in the AppStoreConnect backend


- □ App configuration is as follows


- □ Whether the initialization interface is called at startup
- □ Whether the AppWheel SDK can get the information of purchased products
- □ Subscription Products
- □ Discount products (optional)
- □ Discount for new users
- □ Promotion offer
- □ Coupon
- □ Consumable products
- □ Non-consumable products
- □ Non-renewable products
- □ Whether the AppWheel SDK can restore product information

### Other steps: Integration of advanced features
#### Voucher machine
##### Obtain coupons
Description: Developers should request coupon information as early as possible when necessary.

```Objective-C
AWPurchaseKit queryCouponDetail:((^)(BOOL success,AWCouponModel * _Nullable model, AWError * _Nullable error))completion
```


For the returned AWCouponModel data structure, please refer to document: AppWheel SDK Integration Document - Introduction to iOS Classes 

##### Consume coupon code
Note: The developer should report the task ID to AppWheel after displaying the coupon to complete the statistics.

```Objective-C
AWPurchaseKit updateConponStateWithTaskId:(long)taskId
           withCompletion:((^)(BOOL success, AWError * _Nullable error))completion
```


Parameter: taskId. The value of AWCouponModel, which is obtained from calling the coupon interface.

## Android Integration
### Step 1: Create an app

- **App name**: The name of your app
- **Store**: The platform that is divided into Android and iOS, and you should select Android in this case.
- **Google Play package**: The package name of your app, which is the unique identifier of your app in the Google Play Store and can be obtained in the Google Play Console
- **Service Account credentials JSON**: The json file required by the server to verify the order. Before you obtain this file, please confirm that you have completed the necessary configuration for Google payments, which is described in the Necessary Preparation for AppWheel (Android). When you have completed the configuration, you will have a json file. Please upload this file to our backend to create your Android app accordingly.

### Step 2: Configuration
#### Notification Receiving Configuration (<font color="red"> **Important: If you have your own receiving server, please refer to the "Configure Notification Receiving Server"**</font>)
To send Google server notifications to AppWheel, please configure the address (https://msgserver-dot-subscription-saas.uc.r.appspot.com/subcenter/receive_android_notification) on the Google Cloud Platform.

#### Configure Notification Receiving Server
▪ If you have your own notification receiving server that needs the push data, you can set the receiving server address in the AppWheel main site. We will send each message once in the order in which the messages arrive, but sometimes the messages may not be delivered in sequence, or will be transmitted multiple times. You should design the program in the way of idempotent processing.

▪ After the configuration is complete, you can test the availability of the address. The configuration must be consistent with the requirements, that is, accept the request of the POST method, return 200 Http status code after successful processing, and return 400 or 500 status code when processing fails. In addition, because there is no actual business data body in the test, the 200 http status code can be returned when empty data is received.

#### Product Configuration
##### There's already a product configuration
##### No product configuration

### Step 3: Android SDK interface integration
#### Installation
Requirements:
This SDK is hosted on Maven, and we recommend using gradle to install this SDK.
 Add the following code to the project.gradle file:
 
```java
 repositories {
    ...
    google()
    jcenter()
}

dependencies {
    ...
    classpath 'com.google.gms:google-services:4.2.0'
}

allprojects {
    repositories {
        google()
        jcenter()
    }
}
```

 Add the following code to the app.gradle file:
apply plugin: 'com.google.gms.google-services'

```java
implementation 'com.github.pixocial:purchases:1.0.4'
```



#### Initialize
The SDK initialization method is as follows. Please initialize the SDK in your app as soon as possible according to your own situation.

```java
// 在Application中的oncreate中初始化配置，appId为注册应用时候分配的应用id
Billing.configure(context ,"appid" , appUserId , 
new OnBillingClientSetupFinishedListener(){
    @Override
    public void onBillingSetupFinished(int billingResponseCode) {
        super.onBillingSetupFinished(billingResponseCode);
    }
});
```

```Kotlin
// 在Application中的oncreate中初始化配置，appId为注册应用时候分配的应用id
Billing.configure(context ,"appid" , appUserId , listener)
```


Parameters:
• appId: Generated by the server of the subscription center. For the generation steps, please refer to the document: New Application (External Use) 
• uid: userId, no empty string for transferring
• listener: Initialized listener, which can be empty value. After initialization, the callback result will be successfully returned.
onBillingSetupFinished method

#### Get Products
Requirements:
This method is used to acquire product information. The product information should be loaded before displaying product page.

```java
Market.getInstance().getProductsInfo(itemType, skuList, new OnQueryProductListener() {
    @Override
    public void onSuccess(List<Product> productInfo) {
    }

    @Override
    public void onError(int resultCode) {

    }
});
```

```Kotlin
Market.getInstance().getProductsInfo(itemType, skuList, object : OnQueryProductListener {
    override fun onSuccess(productInfo: List<Product>) {
        
    }
    override fun onError(resultCode: Int) {
        
    }
})
```

Parameters:
￮ itemType: SKU types, including INAPP and SUBS.
￮ skuList : Collection of SKU IDs.
Return:
When the request is successful, the collection of Products will be returned through the onSuccess method.

#### Purchase Products
Requirements:
This method should be called to complete a purchase when a user has selected a product. The developers should tell the product type before calling this method and then pass the productType to complete the purchase.

```java
Market.getInstance().purchaseProduct(ProductDetailActivity.this, mProduct, new InitiatePurchaseListener() {
    @Override
    public void onVerifying(boolean isVerifying) {
       // 后台验证中的回调
    }

    @Override
    public void onPurchaseSuccess(MTGPurchase purchase) {
       // 购买成功回调
   }

    @Override
    public void onOwnedGoods(MTGPurchase purchase) {
       // 已购买状态回调
    }

    @Override
    public void onPurchaseError(int errorCode) {
       // 购买异常回调
    }
});
```

```Kotlin
Market.getInstance().purchaseProduct(activity, mProduct, object : InitiatePurchaseListener {
    override fun onVerifying(isVerifying: Boolean) {
        // 切换后台验证状态回调
    }

    override fun onPurchaseSuccess(purchase: MTGPurchase) {
        // 购买成功回调
    }

    override fun onOwnedGoods(purchase: MTGPurchase) {
        // 已购买状态回调
    }

    override fun onPurchaseError(errorCode: Int) {
        // 购买异常回调
    }
})
```


Parameters:
￮ product: Products to be purchased
Consumption
Requirements:
The paymentType for INAPP products is 2 and there is no need to use this interface for subscription products. If the purchased INAPP products are not consumed, then cannot be purchased again until they are consumed.

```java
Market.getInstance().consumePurchaseFlow(purchase, new ConsumeResponseListener() {
    @Override
    public void onConsumeResponse(int resultCode) {
        if(resultCode == Types.BillingResponseCode.OK){
            BillingLog.i(TAG , "consumeMembership Success -" + purchase.getProductId());
        }
    }
});
```

```Kotlin
Market.getInstance().consumePurchaseFlow(purchase, object : ConsumeResponseListener() {
    fun onConsumeResponse(resultCode: Int) {
        if (resultCode == Types.BillingResponseCode.OK) {
            BillingLog.i(TAG, "consumeMembership Success -" + purchase.getProductId())
        }
    }
})
```


Parameters:
￮ purchase: MTGPurchase type. Please choose the corresponding purchase value according to the products you need.

#### Restore Purchase
Requirements:
This is used to restore valid subscriptions, non-consumable products, and non-renewable products for a user. When there is no valid subscription, the 'success' in the block will return a false value. Calling this interface will directly call the AppleService verification interface and there is a quota restriction for this interface for each app. It is strictly prohibited to call when starting the app and to call it too frequently. It is recommended to call it only when the purchase information fails to be inquired because the user changed their phone or reinstalled the app.

```java
Market.getInstance().restorePurchase(new OnRestorePurchaseListener() {
    @Override
    public void onSuccess(List<MTGPurchase> purchases) {
    }

    @Override
    public void onError(int resultCode) {
    }
});
```

```Kotlin
Market.getInstance().restorePurchase(object : OnRestorePurchaseListener {
    override fun onSuccess(purchases: List<MTGPurchase>) {
    }
    override fun onError(resultCode: Int) {
    }
})
```


#### View User Benefits
The following method is used to check a user's existing purchased products.
Obtain the current valid orders
Requirements:
The following method is used to check a user's existing valid orders, including valid subscription and unconsumed INAPP products.

```java
UserOrderManager.getProvider().getOrders()
```

```Kotlin
UserOrderManager.getProvider().getOrders()
```

Obtain current subscription
Requirements:
This method is used to obtain a user's existing valid subscription. If there is no valid subscription, an empty result will be returned.

```java
SubsPurchase recentSubsPurchase = UserOrderManager.getProvider().getRecentSubsPurchase();
```

```Kotlin
val recentSubsPurchase = UserOrderManager.getProvider().recentSubsPurchase
```

#### Adding a global listener
Requirements:
This method is used to add a global listener, which will be called after purchase, subscription renewal, and/or restoring purchases. Developers should set up listeners as soon as possible after initialization for callbacks in a timely manner.

```java
/// 添加监听
UserOrderManager.getProvider().addPurchaseObserver(new OrderObserver() {
    @Override
    public void onUpdateOrders(List<MTGPurchase> purchases) {
        // 在这里监听订单变化情况
    }
});
///移除监听
UserOrderManager.getProvider().removePurchaseObserver(orderObserver);
```

```Kotlin
/// 添加监听
UserOrderManager.getProvider().addPurchaseObserver {
    // 客户端在这里监听中台的订单变化情况
} 
///移除监听
UserOrderManager.getProvider().removePurchaseObserver(orderObserver)
```

### Step 4: Acceptance Inspection
- □ App Configuration Check
- □ To make sure a notification is configured successfully: Check if the Google Cloud Pub/Sub queue has notification settings

- □ The basic configuration is as follows

- □ Whether the initialization interface is called at startup
- □ Whether the AppWheel SDK can get the information of purchased products
- □ Subscription Products
- □ In-App Products
- □ Discount products (optional)
- □ Single Payment Products
- □ Recurring Payment Products
- □ Whether the AppWheel SDK can restore product information
### Other steps: Integration of advanced features

